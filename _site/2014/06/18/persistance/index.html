<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
      
        Persistence &middot; PCS
      
    </title>

    <script type="text/javascript" src="../scripts/jquery-2.1.0.min.js"></script>

    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="../css/master.css">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  </head>

  <body class="pure-g">
    <header class="pure-u-1">
      <nav class="pure-menu pure-menu-open pure-menu-horizontal">
        <ul>
          <li>
            <a href="/">JavaScript Evening</a>
          </li>
          <li>
            <a id="" href="/">About</a>
          </li>
          

          
          
            
              
            
          
            
              
                <li>
                  <a id="" href="/syllabus/">Syllabus</a>
                </li>
              
            
          
            
              
            
          
            
              
                <li>
                  <a id="" href="/curriculum/">Curriculum</a>
                </li>
              
            
          
            
          
            
              
                <li>
                  <a id="" href="/resources/">Resources</a>
                </li>
              
            
          
          <li>
            <a href="http://portlandcodeschool.com/" class="nav-item">PCS Home</a>
          </li>
        </ul>
      </nav>      
    </header>

    <section class="pure-u-1">
      <div class="post">
  <h1 class="post-title">Persistence</h1>
  <span class="post-date">18 Jun 2014</span>
  <span class="post-slides">

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

</span>

  <p>Today we&#39;re going to learn about persistence using <em>SQL</em> (pronounced <em>sequel</em>
or <nobr><em>S-Q-L</em></nobr>), <a href="http://bookshelfjs.org">Bookshelf.js</a> and <a href="http://www.postgresql.org">PostgreSQL</a>
(pronounced <nobr><em>post-gres-q-l</em></nobr> or <nobr><em>post-gres</em></nobr>).</p>

<p>There&#39;s a ton of information here, but much of it is really just repeating the
same ideas both in native SQL and in an abstraction layer that allows us to
work mostly in JavaScript.</p>

<h2>SQL</h2>

<p>SQL stands for Structured Query Language for working with relational databases.
The SQL language has been standardized, but it&#39;s very difficult to ensure that
all SQL queries works with every database management systems (DBMS).</p>

<p><aside>
We&#39;ll touch on some of the basis of SQL, but there is a lot to it. If you&#39;re
feeling up for it, continue to push yourself with SQL as we move forward and
see if you can write queries to produce the same data that Bookshelf.js gets
you.
</aside></p>

<h2>Install PostgreSQL</h2>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">brew install postgresql</code></pre></div>

<p>Once installed, read the on-screen instructions. You should only have to
configure <code>launchd</code> via <code>launchctl</code>, but these things change from time to
time.</p>

<p>Once installed, you&#39;ll have a tool called <code>psql</code> that you can use to connect
to the PostgreSQL database server running on your computer.</p>

<h2>Databases</h2>

<p>Once connected, let&#39;s create a database called <code>test</code> that we can work with.
Try to figure this one out on your own.</p>

<h3>Tables</h3>

<p>In order to store data in the database, you&#39;ll want to create some tables. One
of the easiest ways to think of a table is as a big spreadsheet. There are a
bunch of pre-defined columns in a table, and you can add rows of data to it.
Each column has a pre-defined type (just like spreadsheets). There&#39;s a lot of
options when creating tables which you can see with <code>\h create table</code>.</p>

<p>The available types are: <code>bigint</code>, <code>bit</code>, <code>bit varying</code>, <code>boolean</code>, <code>char</code>, <code>character varying</code>, <code>character</code>, <code>varchar</code>, <code>date</code>, <code>double precision</code>, <code>integer</code>, <code>interval</code>, <code>numeric</code>, <code>decimal</code>, <code>real</code>, <code>smallint</code>, <code>time</code> (with or without time zone), <code>timestamp</code> (with or without time zone), and <code>xml</code>.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">create table businesses (name varchar(20), established timestamp);

insert into businesses values (&#39;ABC Corp&#39;, &#39;2010-04-15&#39;);
insert into businesses values (&#39;XYZ Inc.&#39;, to_timestamp(1338350400.000));
insert into businesses values (&#39;Long Name Company Incorporated&#39;, &#39;2014-12-22&#39;);

select * from businesses;
select name, established from businesses;
select name, extract(epoch from established) from businesses;</code></pre></div>

<h3>Where</h3>

<p>We can request subsets of data by specifying a <code>where</code> clause:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">select * from businesses where established &gt;= &#39;2011-01-01&#39;;</code></pre></div>

<h3>Update</h3>

<p>We can udpate objects as well by specifying which ones:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">update businesses set name = &#39;XYZ Incorporated&#39; where name = &#39;XYZ Inc.&#39;;</code></pre></div>

<h3>Delete</h3>

<p>We can delete objects as well by specifying which ones:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">delete from businesses where established &lt; &#39;2011-01-01&#39;;</code></pre></div>

<h2>Relationships</h2>

<p>We called this a relational database, so we need to actually support relationships.</p>

<h3>One-to-Many</h3>

<p>A one-to-many relationship is where one object <em>has many</em> of another.
Businesses have many employees, hospitals have many doctors, countries have
many cities, etc. When we&#39;re referring to the other side of the relationship
we say that an employee <em>belongs to</em> a company, a doctor belongs to a hospital
or a city belongs to a country.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">create table countries (id serial primary key, name varchar(20), independence timestamp);
create table cities (id serial primary key, name varchar(255), country_id int references countries(id));</code></pre></div>

<p>The most common way to create relationships is to give each table it&#39;s own
<code>id</code>. This column will uniquely identify each row in the table and will never
change for a particular object. It will also be <em>indexed</em> by the database to
provide faster lookup for these relationships.</p>

<p>The <code>serial</code> type allows us to quickly state that this column will contain
integers that automatically increment as values are inserted. Rather than
inserting a specific value, we can simply skip that value and it&#39;ll get a new
id.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">insert into countries (name, independence) values (&#39;USA&#39;, &#39;1776-07-04&#39;);
insert into countries (name, independence) values (&#39;Canada&#39;, &#39;1867-07-01&#39;);
insert into countries (name, independence) values (&#39;Mexico&#39;, &#39;1821-09-28&#39;);
insert into countries (name, independence) values (&#39;Argentina&#39;, &#39;1816-07-09&#39;);
select lastval(); /* get the id that was produced for the last insert */
select * from countries;</code></pre></div>

<p>Now let&#39;s insert some related objects:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">insert into cities (name, country_id) values (&#39;Portland&#39;, 1);
insert into cities (name, country_id) values (&#39;Washington DC&#39;, 1);
insert into cities (name, country_id) values (&#39;Montreal&#39;, 2);
insert into cities (name, country_id) values (&#39;Ottawa&#39;, 2);
insert into cities (name, country_id) values (&#39;D.F.&#39;, 3);
insert into cities (name, country_id) values (&#39;Guadalajara&#39;, 3);
insert into cities (name, country_id) values (&#39;Buenos Aires&#39;, 4);
insert into cities (name, country_id) values (&#39;Mendoza&#39;, 4);
select * from cities;</code></pre></div>

<p>Now let&#39;s find all of the cities and the country in which they&#39;re located:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">select * from cities
left join countries
on cities.country_id = countries.id;

select cities.* from cities
left join countries
on cities.country_id = countries.id;

select cities.name, countries.name from cities
left join countries
on cities.country_id = countries.id;</code></pre></div>

<p>That <code>references countries(id)</code> is called a <em>foreign key constraint</em>. The
database will prevent us from making mistakes, creating or deleting objects
with broken relationships.</p>

<p>Try both of these:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">insert into cities (name, country_id) values (&#39;London&#39;, 5);
delete from countries where name = &#39;USA&#39;;</code></pre></div>

<p><aside>
<strong>Constraints</strong></p>

<p>Databases allow us to create other constraints allowing us to specify rules to
keep our data in a <em>consistent</em> state. We can ensure that a column contains
unique values. We can specify that a few columns don&#39;t ever repeat the same
combination of values. We can keep a column from containing null values.</p>

<p><strong>Joins</strong></p>

<p>For those of you who are curious about the options on how to select data across
multiple tables, there are many <code>JOIN</code> options available. We&#39;re not going to
dig into them now because Bookshelf.js (and most object relational mappers)
will handle this automatically for us.</p>

<p>There&#39;s a great <a href="http://blog.codinghorror.com/a-visual-explanation-of-sql-joins/">visual overview</a> of different join types that you
can read about, though. Note the comment from the author, Jeff Atwood, though:</p>

<blockquote>
<p>The commenters pointing out that the diagrams break down in case of multiple
and or duplicate results, are absolutely right. I was actually thinking of
joins along the primary key, which tends to be unique by definition, although
the examples are not expressed that way.</p>
</blockquote>

<p>Like the cartesian or cross product, anything that results in more rows than you originally started with does absolutely breaks the whole venn diagram concept. So keep that in mind.
</aside></p>

<h3>Many-to-Many</h3>

<p>Many-to-many relationships are the hardest type of relationships. If we want to
have people who are residents of cities, we could do that with a one-to-many
relationship like we did above, but sometimes people split their time between
multiple locations.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">create table people (id serial primary key, name varchar(255));
insert into people (name) values (&#39;Whitney&#39;), (&#39;David&#39;), (&#39;Jonathan&#39;);</code></pre></div>

<p>Now we have cities and people, but we have no relationship between the two. We
actually need to build a new table to hold the relationships. The table will
simply contain two foreign keys, one to reference the city, and one to
reference the person. It&#39;s easier with an example:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">id |   name
----+----------
  1 | Whitney
  2 | David
  3 | Jonathan

 id |     name
----+---------------
  1 | Portland
  2 | Washington DC
  3 | Montreal
  4 | Ottawa</code></pre></div>

<p>How do we relate Whitney to Portland? That&#39;s <code>1</code> in the people and <code>1</code> in the
cities. David to Ottawa? <code>2</code> in people and <code>4</code> in cities. Since Jonathan lives
in Ottawa as well, we&#39;ll put <code>3</code> in people and <code>4</code> in cities. Jonathan also
spends half the year in Washington DC, so we&#39;ll need a <code>3</code> in people and <code>2</code> in
cities for that.</p>

<p>So we end up with a table of relations that looks like this. Since the database
supports relationships so well, we&#39;ll be able to use this table to build up
queries telling us who lives where.</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">person_id | city_id
-----------+---------
         1 |       1
         2 |       4
         3 |       4
         3 |       2</code></pre></div>

<p>Creating this table is pretty straight forward:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">create table residences (person_id int references people(id), city_id int references cities(id));
insert into residences values (1, 1), (2, 4), (3, 4), (3, 2);</code></pre></div>

<p>Actually getting the data you want out of the three tables that we now have gets
complicated.</p>

<p>Cities in which a specific person lives:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">select cities.*
from people
left join residences on people.id = residences.person_id
inner join cities on cities.id = residences.city_id
where people.id = 3;</code></pre></div>

<p>People who live in a specific city:</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">select people.*
from cities
left join residences on cities.id = residences.city_id
inner join people on people.id = residences.person_id
where cities.id = 4;</code></pre></div>

<p>All people and the city in which they live (or no city at all):</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">select people.*, cities.*
from people
left join residences on people.id = residences.person_id
left join cities on cities.id = residences.city_id;</code></pre></div>

<h3>One-to-One</h3>

<p>One-to-one relationships are created by basically limiting a one-to-many
relationship to a single item instead of many. So if a work order <em>has a</em>
receipt, you may want to store these two models in different tables.</p>

<p>Where does the foreign key go? It really doesn&#39;t matter to the database, but
if we can have some consistency, that&#39;ll be a good thing. In the one-to-many
country and city example, we said that a country <em>has many</em> cities and that
a city <em>belongs to</em> a country. We then added a foreign key of <code>country_id</code> to
each city. If a work order <em>has a</em> receipt. Then a receipt <em>belongs to</em> a work
order, and we&#39;ll put a <code>work_order_id</code> column in the receipt. To ensure there&#39;s
only one receipt per work order, the <code>work_order_id</code> should be a foreign key
with a unique constraint.</p>

<h2>Transactions</h2>

<p>Transactions allows you to group together multiple commands and either <em>commit</em>
the entire group at once or <em>rollback</em> everything if you&#39;ve realized that
something isn&#39;t quite right.</p>

<p>Transactions allow us to better ensure <em>consistency</em> in our database. If we
want to create a user at the time that they sign up, but we also need to make
sure that they have an account created for them, we can do both of those
together. If both succeed, we can commit the transaction. If either fails, we
can roll it back.</p>

<p>Imagine the frustration a user could experience if we didn&#39;t use a transaction.
The user tries to sign up. The user data gets created in the database, but for
some reason, the account creation fails. Now the user tries to sign in. If you
verify that the user has an account during sign-in, then you may end up telling
them that they&#39;re not able to access their account (or some similar error). But
the user just signed up! What?</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">create table businesses (name varchar(255), established timestamp);
create table employees (first_name varchar(255), last_name varchar(255), business_id int references businesses(id));

begin;
insert into businesses (name, established) values (&#39;ABC Corp&#39;, &#39;2010-04-15&#39;);
insert into employees (first_name, last_name, business_id) values (&#39;Whitney&#39;, &#39;Young&#39;, lastval());
select * from businesses;
select * from employees;
commit;
select * from businesses;
select * from employees;

begin;
insert into businesses (name, established) values (&#39;XYZ Inc&#39;, &#39;2010-04-15&#39;);
insert into employees (first_name, last_name, business_id) values (&#39;John&#39;, &#39;Doe&#39;, lastval());
select * from businesses;
select * from employees;
rollback;
select * from businesses;
select * from employees;</code></pre></div>

<p>Oh, and guess what? If a statement fails, the whole transaction is rolled back
regardless. So wrapping statements between <code>begin</code> and <code>commit</code> will ensure
that either the whole group of statements succeed or fail as a group. Yay!</p>

<h2>More SQL</h2>

<p>There is a lot more that you can do with SQL from stored procedures to custom
data types. Some people go very in depth with SQL and handle improving query
performance, scaling database infrastructure to support a lot of data, etc.
If you&#39;re interested in how large companies handle this type of thing, spend a
little time reading about how to improve performance or scale an app.</p>

<p><aside>
<strong>MySQL &amp; Others</strong></p>

<p>MySQL is another popular open source database. Much of what you&#39;ve learned
will apply directly to using MySQL. There are slight differences in more
specialized queries like <code>serial</code> which MySQL does via
<code>int not null auto_increment</code>. Simple queries are generally compatible across
DBMS systems, but more advanced queries do not directly translate. Focus on
PostgreSQL for now, but don&#39;t be scared if a project that you start working on
uses another SQL database.</p>

<p><strong>Explain</strong></p>

<p>Put <code>explain</code> before any query to see how the database will handle the query.
This is a great tool for figuring out why a query is taking a long time.
Another option is <code>explain analyze</code> which actually executes the query. Since
the query is executed, you may wish to wrap this in a transaction (as it will
actually insert/update/delete objects).</p>

<div class="highlight"><pre><code class="language-sql" data-lang="sql">begin;
explain analyze ...;
rollback;</code></pre></div>

<p></aside></p>

<h2>SQL Challenges</h2>

<ul>
<li>Create a table that uses a date. Insert some data. Select all of the entries
that occur between some date range.</li>
<li>Create a one-to-many relationship between <code>articles</code> and their <code>comments</code>. Be
able to select which article a comment is for, and all of the comments for an
article.</li>
<li>Create a many-to-many relationship between users and permissions. Be able to
select the users that fall under a permission group. Also be able check to see
if a user has a given permission. For instance, does the user with email
<code>whitney@portlandcodeschool.com</code> have permission to <code>blog_article.create</code>? Who
are all of the users who have permissions to <code>blog_article.destroy</code>?</li>
<li><strong>Advanced:</strong> Model a file system with files and directories. You should be
able to get a directory&#39;s contents and the parent directory.</li>
<li><strong>Advanced:</strong> Model family relationships. Support people who have a <code>name</code>
and <code>gender</code>. You should be able to query for:

<ul>
<li>A person&#39;s mother</li>
<li>A person&#39;s father</li>
<li>A person&#39;s children</li>
<li>A person&#39;s siblings</li>
<li>A person&#39;s grandmothers &amp; grandfathers</li>
<li>A person&#39;s maternal grandmother/grandfather</li>
<li>A person&#39;s grandchildren</li>
<li>Cousins, etc.</li>
</ul></li>
</ul>

<h2>A Quick Look at Node&#39;s PG module</h2>

<p>So how do we write SQL from JavaScript? One way to do it is to connect to the
SQL server and write the SQL queries by hand. Let&#39;s give it a try:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">npm install pg</code></pre></div>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">// node index.js 1
var pg = require(&#39;pg&#39;);
var settings = &quot;postgres://localhost/test&quot;; // &quot;postgres://username:password@localhost/database&quot;;
var id = process.argv[2];

if (process.argv.length &lt;= 2) { return console.error(&#39;please provide an id to look up&#39;); }

pg.connect(settings, function(err, client, done) {
  if (err) { return console.error(&#39;error fetching client from pool&#39;, err); }

  client.query(&#39;select * from people where id = $1::int&#39;, [id], function(err, result) {
    done();

    if (err) { return console.error(&#39;error running query&#39;, err); }
    console.log(&#39;%j&#39;, result.rows[0]);

    pg.end(); // completely finished with the database for this app
  });
});</code></pre></div>

<h2>Bookshelf.js &amp; Knex.js</h2>

<p><a href="http://bookshelfjs.org">Bookshelf.js</a> is an <em>object relational mapper</em> or <em>ORM</em>. It allows
us to work with objects in JavaScript instead of writing SQL queries manually.
<a href="http://knexjs.org">Knex.js</a> is the <em>query builder</em> off of which Bookshelf.js is built. A
query builder allows us (and Bookshelf.js) to build queries from JavaScript
expressions that can be converted to any supported DBMS.</p>

<p>So using these tools, we can theoretically write code that would work with any
of the SQL databases without having to worry about differences between them. In
practice, since the differences are subtle, and the best practice is to choose
one database for a project, and use it for production and for the entire
development team.</p>

<p><aside>
<strong>So I Don&#39;t Need to Know SQL?</strong></p>

<p>While we&#39;ll focus on Bookshelf.js and Knex.js, you absolutely need to continue
to develop your skills with SQL. Unlike programming languages that completely
abstract away the lower level interaction with assembly language, ORM tools do
not completely abstract away SQL. They just make the most common tasks more
expressive and digestible.
</aside></p>

<p>To install, we&#39;ll all three of these modules we&#39;ve discussed, plus <em>Bluebird</em>,
a <em>promise</em> library. You&#39;ll see promises in action in just a second!</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">npm install bookshelf knex pg bluebird</code></pre></div>

<h3>Migrations</h3>

<p>Let&#39;s specify the creation of tables and relationships directly in JavaScript.
To do so, run:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">./node_modules/.bin/knex init</code></pre></div>

<p>Then modify the <code>knexfile.js</code> file that it contains:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">client: &#39;postgres&#39;,
connection: {
  host     : process.env.APP_DB_HOST     || &#39;127.0.0.1&#39;,
  user     : process.env.APP_DB_USER     || &#39;&#39;,
  password : process.env.APP_DB_PASSWORD || &#39;&#39;,
  database : process.env.APP_DB_NAME     || &#39;jsi-bookshelf&#39;
}</code></pre></div>

<p>Finally, we can create a migration:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">./node_modules/.bin/knex migrate:make countries</code></pre></div>

<p><aside>
<strong>127.0.0.1</strong></p>

<p>Otherwise known as <em>home</em> or <em>localhost</em>, this IP address is technically called
the loopback interface. Oh, terminology.
</aside></p>

<p>Once ready, we can fill out our <code>20140510084914_countries.js</code>. Yours is named
differently? It better be. Using timestamps allows Knex.js to know what order
to apply migrations. It also avoids the possibility of two developers creating
a migration with the same name (which would cause merge conflicts in our
version control system).</p>

<p>Migrations allow us to collaborate better. Without this we would have to alter
the database <em>schema</em> to match the changes that another developer made. Doing
this manually is error prone, so most communities have built automation tools
to aid with this process.</p>

<p>So here&#39;s a <a href="http://knexjs.org/#Schema">migration</a>:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">&#39;use strict&#39;;

exports.up = function(knex, Promise) {
  return knex.schema.createTable(&#39;countries&#39;, function(table) {
    table.increments(&#39;id&#39;).primary();
    table.string(&#39;name&#39;);
  });
};

exports.down = function(knex, Promise) {
  return knex.schema.dropTable(&#39;countries&#39;);
};</code></pre></div>

<p>We can now migrate forward or backward:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">./node_modules/.bin/knex migrate:latest
./node_modules/.bin/knex migrate:rollback</code></pre></div>

<p>If you add <code>debug: true</code> to your <code>knexfile.js</code> <code>development</code> setting, you can
even see the SQL queries that Knex.js is running.</p>

<p><aside>
<strong>Migration Tracking</strong></p>

<p>You&#39;ll notice a new table added to your database called <code>knex_migrations</code>. This
table tracks the migrations you&#39;ve applied thus far so it knows what&#39;s left to
apply.
</aside></p>

<h3>Challenge</h3>

<p>Create another migration for the <code>cities</code> table. This should match up with the
cities table that we created before.</p>

<h2>Basic Manipulation</h2>

<p>Now we need to learn how to use Bookshelf.js to interact with the database.</p>

<h3>Modeling</h3>

<p>We need to define the objects that we want to work with. This may seem tedious
at this point, but we get to skip over any attributes and just define which
model the table works with.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var env = process.env.NODE_ENV || &#39;development&#39;;
var knexConfig = require(&#39;./knexfile.js&#39;)[env];
var knex = require(&#39;knex&#39;)(knexConfig);
var bookshelf = require(&#39;bookshelf&#39;)(knex);

var Country = bookshelf.Model.extend({
  tableName: &#39;countries&#39;
});</code></pre></div>

<h3>Insert</h3>

<p>Now we can create and save objects via <code>new</code> or <code>forge</code>:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">// new Country({ name: &#39;Canada&#39; }).save().... also works
Country.forge({ name: &#39;Canada&#39; }).save().then(function(country) {
  console.log(&#39;created a country %j&#39;, country.toJSON());
})
.done();</code></pre></div>

<h3>Queries</h3>

<p>Querying is pretty easy via:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">Country.where({ name: &#39;Canada&#39; }).fetchAll().then(function(result) {
  console.log(result.toJSON());
})
.done();</code></pre></div>

<p><aside>
<strong>Promises</strong></p>

<p>That&#39;s a lot of new stuff up in that example code there, you better ask some
questions.
</aside></p>

<h2>Bookshelf Challenges</h2>

<p>Go explore <a href="http://bookshelfjs.org">the documentation</a> and figure out how to create
one-to-one and one-to-many relationships. Figure out how to create objects in
these relationships and query for them. Also make sure you can delete and
update objects of each type of relationship.</p>

<h3>Simple Usage</h3>

<ul>
<li>Define a migration</li>
<li>Create an object</li>
<li>Read an object</li>
<li>Update an object</li>
<li>Delete an object</li>
<li>Search through objects for something specific</li>
</ul>

<h3>One-to-Many</h3>

<ul>
<li>Define two tables in a migration</li>
<li>Create an object on the <em>one</em> end of the relationship</li>
<li>Create a few of the other type</li>
<li>Search for a model on the <em>one</em> side based on a condition for something from
the <em>many</em> side</li>
<li>Search for all models on the <em>many</em> side that match a specific condition
individually and are associated with a particular instance on the <em>one</em> side</li>
<li>Delete specific objects on the <em>many</em> side</li>
<li>Delete all objects on the <em>many</em> side &amp; the object on the <em>one</em> side within a
transaction</li>
</ul>

<h3>Many-to-Many</h3>

<ul>
<li>Define the required three tables in a migration</li>
<li>Create a bunch of objects that relate</li>
<li>Write queries to access them through their relationships</li>
</ul>

</div>



    </section>

    <footer class="pure-u-1">
      &copy; 2014. All rights reserved.
      <span>v0.0.1</span>
    </footer>
  </body>
</html>
