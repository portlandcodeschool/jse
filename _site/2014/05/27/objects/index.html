<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
      
        Making Objects &middot; PCS
      
    </title>

    <script type="text/javascript" src="../scripts/jquery-2.1.0.min.js"></script>

    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="../css/master.css">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  </head>

  <body class="pure-g">
    <header class="pure-u-1">
      <nav class="pure-menu pure-menu-open pure-menu-horizontal">
        <ul>
          <li>
            <a href="/">JavaScript Evening</a>
          </li>
          <li>
            <a id="" href="/">About</a>
          </li>
          

          
          
            
              
            
          
            
              
                <li>
                  <a id="" href="/syllabus/">Syllabus</a>
                </li>
              
            
          
            
              
            
          
            
              
                <li>
                  <a id="" href="/curriculum/">Curriculum</a>
                </li>
              
            
          
            
          
            
              
                <li>
                  <a id="" href="/resources/">Resources</a>
                </li>
              
            
          
          <li>
            <a href="http://portlandcodeschool.com/" class="nav-item">PCS Home</a>
          </li>
        </ul>
      </nav>      
    </header>

    <section class="pure-u-1">
      <div class="post">
  <h1 class="post-title">Making Objects</h1>
  <span class="post-date">27 May 2014</span>
  <span class="post-slides">

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

</span>

  <p>It&#39;s been a long time coming. We&#39;re ready to discuss objects in detail! Many
languages and courses discuss this very early in the course. JavaScript is a
bit different because how your interaction with objects thus actually provides
a lot of functionality without adding too much complexity and jargon. But now
it&#39;s time to dive in.</p>

<h2>Containers For Related Functionality</h2>

<p>Remember how objects let us group things together? We made a person that had
a <code>firstName</code> and <code>lastName</code>. Well this got us pretty far, but let&#39;s take
things a little further, try to build something a little bigger.</p>

<p>Let&#39;s pretend that we&#39;re building an application that models a tennis practice.
What&#39;s that involve? A bunch of objects!</p>

<ul>
<li>People</li>
<li>Court</li>
<li>Tennis Balls</li>
<li>Tennis Raquets</li>
<li>Ball basket</li>
<li>Ball machine</li>
</ul>

<p>That list could probably go on forever. We&#39;re going to explore the person and
the ball machine.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var person = {
  name: &#39;Whitney&#39;,
  age: 11
};
var ballMachine = {
  capacity: 100,
  speed: {
    max: 80,
    min: 20
  },
  delay: {
    max: 60,
    min: 1
  }
};</code></pre></div>

<p>Please don&#39;t run that ball machine shooting balls at 80mph every second!</p>

<p>Now let&#39;s start a drill. We&#39;ll need to run the ball machine, and the person
will have to try to hit the ball back by running over to wherever it lands and
hitting it.</p>

<p>Ok, that shouldn&#39;t be so hard to model:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">/**
 * Run a ball machine.
 * @param {object} ballMachine - The ball machine to run.
 * @param {object} settings - Settings on which to run. You can include
 * `speed` and `delay` which must be within the thresholds of the
 * machine.
 * @param {function} cb - Called when each ball is fired.
 */
var run = function(ballMachine, settings, cb) {
  // implementation eventually does something like
  cb({ speed: 40, direction: &#39;5deg&#39; });
};</code></pre></div>

<p>Now we just need to be able to make the person run to hit the ball:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">/**
 * Make a person run to a location.
 * @param {object} person - The person to make run.
 * @param {object} location - Where you want the person to run.
 * @param {function} cb - Called when the person arrives at the location.
 */
var run = function(person, location, cb) {
  // implementation eventually does something like
  cb({ location: location });
}</code></pre></div>

<p>Well, we can&#39;t have two functions named <code>run</code>. So we have to make things more
verbose. Let&#39;s call them <code>runBallMachine</code> and <code>personRun</code>. Or we could just
rename them entirely. We could <code>start</code> the ball machine and still have the
person <code>run</code>. But then what if we eventually had a lesson that we wanted to
<code>start</code>? What if instead we could just associate the functions with the
objects that they represent? A person can <code>run</code> and a ball machine can <code>run</code>
too!</p>

<h2>Objects</h2>

<p>We&#39;re going to break things up now, so that we can group functions together in
and use them with objects the same way that we did before with properties. This
grouping that we&#39;re doing is actually a <em>separation of concerns</em>.</p>

<p>Here&#39;s what we want:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">ballMachine.run(function(info) {
  var speed = info.speed;
  var direction = info.direction;

  var location;
  // figure out where the person needs to go based
  // on the current location of the person and the
  // expected final destination of the ball that
  // was just fired.

  person.run(location)
});</code></pre></div>

<p>This should look familiar. We&#39;ve done this already with <code>array.forEach</code>,
<code>array.map</code>, <code>string.toUpperCase</code>, <code>string.toLowerCase</code>, <code>date.getYear</code>, etc.</p>

<p>Now we&#39;re going to learn how to make that work for our own objects.</p>

<h3>Creating Objects</h3>

<p>Remember how we created a date?</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var date = new Date();</code></pre></div>

<p>That was different from arrays, strings, and other objects. We did those like
so:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var array = [];
var string = &quot;&quot;;
var object = {};</code></pre></div>

<p>But guess what? You can create each of those through the use of <code>new</code> as well.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var array = new Array();
var string = new String();
var object = new Object();</code></pre></div>

<p>So how can we make our own type that works with <code>new</code>?</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var person = new Person();</code></pre></div>

<p>The answer is surprisingly simple (and mind-bendingly confusing). It&#39;s a function.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var Person = function() {
};
var person = new Person();</code></pre></div>

<p>At this point, this just looks like a weird way of calling a function. There&#39;s
more going on behind the scenes, though. We&#39;ll get to that soon.</p>

<h4>Quick Status Check</h4>

<ul>
<li>Update <code>Person</code> to accept <code>firstName</code> and <code>lastName</code> as arguments</li>
<li>Pass those arguments when you create the object for <code>person</code></li>
</ul>

<h3>Jargon</h3>

<p>So now we have <code>Person</code> and <code>person</code>. They&#39;re both logical names, but we don&#39;t
have a language to discuss them distinctly.</p>

<p><code>Person</code> is a <em>class</em>. Classes are the foundation of <em>object oriented
programming</em>. <code>person</code> is an <em>instance</em>. When we create an <em>instance</em> of a
class, that&#39;s called <em>instantiation</em>. When you instantiate an object, its
<em>constructor</em> is called. The constructor in this case is the <code>Person</code> function.
As we&#39;ll see <em>classes</em> will give us a dedicated area in which we can add
procedures that are specific to that kind of object.</p>

<p>We&#39;re going to start using this jargon right away. You&#39;ll likely forget some of
these terms since your brain has been working so hard. Feel free to interrupt
and ask to clarify when the jargon is keeping you from understanding.</p>

<p><aside>
<strong>Case Convention</strong></p>

<p>You&#39;ll notice that all classes use names that start with an uppercase letter.
This is not required, but this convention helps us quickly distinguish between
names that represent classes and instances.
</aside></p>

<h3>Adding Methods</h3>

<p>We&#39;ll now extend our <code>Person</code> class so that instances can call <code>run</code>.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">Person.prototype.run = function() {
  console.log(&#39;I can run!&#39;);
};
var person = new Person();
person.run();</code></pre></div>

<p>What? <code>prototype</code>? What&#39;s that? Simplest answer: just go with it for right now.
Accept it and don&#39;t let your brain tell you that it needs to know. Just know
that now your instance can now call the <code>run</code> method.</p>

<p>If you need a better way to think about it:</p>

<p><section class="conceptual-code"></p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">Person.instanceMethods.run = function() {
  console.log(&#39;I can run!&#39;);
};</code></pre></div>

<p></section></p>

<p><aside>
<strong>Prototype</strong></p>

<p>Seriously, don&#39;t worry about it right now. If you really need to know, come
back to this blurb in the future.</p>

<p>When you&#39;re ready for it, what you&#39;ll want to research is prototypal
inheritance. Don&#39;t start looking into it until you&#39;ve really mastered
inheritance. I&#39;m talking like 3 months down the line.</p>

<p>The reason this can be so confusing is because JavaScript doesn&#39;t easily expose
the same paradigm that most developers have come to know very well, object
oriented design. It&#39;s possible to create an object oriented system with
JavaScript, though. So it&#39;s really just confusing because we&#39;re making
JavaScript do something that&#39;s not convenient in the language. When you combine
that with the history of poor documentation on JavaScript, things get ugly.</p>

<p>If you read all the way through this and are still curious, you&#39;re an adult.
Make an informed choice. We&#39;ll always be here to answer questions! :)
</aside></p>

<h3>Functions vs Methods</h3>

<p>Up until now, you may have noticed both the use of function and method. We&#39;ve
completely skipped over the distinction until now.</p>

<p>Methods are functions that are defined on objects. Functions are functions.
This distinction allows us to easily understand when you need to write
<code>obj.something()</code> vs <code>something()</code>.</p>

<p>We&#39;ve only been writing functions up until now. We&#39;ve been using methods (like
the ones discussed in <a href="#objects">the objects section</a>). Now we&#39;ll be defining
methods as well.</p>

<h3>Data</h3>

<p>Right now our people can&#39;t do anything. They don&#39;t even have names. We need
to associate data with them. Before, we did that via properties. And we will
again.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var person = new Person();
person.firstName = &quot;Whitney&quot;;
person.lastName = &quot;Young&quot;;
console.log(&#39;%s %s&#39;, person.firstName, person.lastName);</code></pre></div>

<p>That still works just fine. But what if you want to set the first and last name
in the constructor?</p>

<p><section class="conceptual-code"></p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var Person = function(firstName, lastName) {
  person.firstName = &quot;Whitney&quot;;
  person.lastName = &quot;Young&quot;;
};</code></pre></div>

<p></section></p>

<p>In the code above, <code>person</code> is not defined. We need a way of accessing the
<em>current instance</em> that&#39;s being worked with. Whenever you create an object or
call a method on it, the code is being invoke on behalf of that object. So that
code has every right to know which object that is.</p>

<p>We use the keyword <code>this</code> to refer to the object on which the method is
invoked.</p>

<h4>Status Check</h4>

<ul>
<li>Fix the code above.</li>
<li>Create a new person.</li>
<li>Log the person&#39;s first and last name.</li>
<li>Add a <code>fullName</code> method and log that.</li>
</ul>

<h3>Encapsulation</h3>

<p>Sometimes we want properties to be accessible by people who use instances of
our classes. Sometimes we don&#39;t. Usually we don&#39;t. Protecting the properties
so that people using the class can&#39;t access them is called <em>encapsulation</em>.</p>

<p>This is often done to make later alterations to a class easier. For instance,
image the following:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var Person = function(name) {
  this.name = name;
};
var person = new Person(&quot;Whitney Young&quot;);
console.log(person.name);
person.name = &quot;Whit Young&quot;;
console.log(person.name);</code></pre></div>

<p>If someone later decides that they want to allow first and last names, they
may change the code:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var Person = function(firstName, lastName) {
  // we used to accept just one argument, name, so
  // be backwards compatible with that.
  if (arguments.length === 1) {
    var names = arguments[0].split(&#39; &#39;);
    firstName = names[0];
    lastName = names[1];
  }
  this.firstName = firstName;
  this.lastName = lastName;
  this.name = [firstName, lastName].join(&#39; &#39;);
};
var person = new Person(&quot;Whitney Young&quot;);
console.log(person.name);
console.log(person.firstName);
console.log(person.lastName);
person.name = &quot;Whit Young&quot;;
console.log(person.name);
console.log(person.firstName);
console.log(person.lastName);</code></pre></div>

<p>Allowing someone to access these properties manually caused our name property
to end up in a bad state.</p>

<p>If we had instead started with:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var Person = function(name) {
  this._name = name;
};
Person.prototype.name = function() {
  return this._name;
}
Person.prototype.setName = function(name) {
  this._name = name;
}
var person = new Person(&quot;Whitney Young&quot;);
console.log(person.name());
person.setName(&quot;Whit Young&quot;);
console.log(person.name());</code></pre></div>

<p>We can add first and last names without consequence:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">var Person = function(firstName, lastName) {
  // we used to accept just one argument, name, so
  // be backwards compatible with that.
  if (arguments.length === 1) {
    this.setName(arguments[0]);
  }
  else {
    this._firstName = firstName;
    this._lastName = lastName;
    this._name = [firstName, lastName].join(&#39; &#39;);
  }
};
Person.prototype.name = function() {
  return this._name;
}
Person.prototype.setName = function(name) {
  var names = name.split(&#39; &#39;);
  this._firstName = names[0];
  this._lastName = names[1];
  this._name = name;
}
Person.prototype.firstName = function() {
  return this._firstName;
}
Person.prototype.setFirstName = function(firstName) {
  this._firstName = firstName;
  this._name = [this._firstName, this._lastName].join(&#39; &#39;);
}
Person.prototype.lastName = function() {
  return this._lastName;
}
Person.prototype.setLastName = function(lastName) {
  this._lastName = lastName;
  this._name = [this._firstName, this._lastName].join(&#39; &#39;);
}
var person = new Person(&quot;Whitney Young&quot;);
console.log(person.name());
console.log(person.firstName());
console.log(person.lastName());
person.setName(&quot;Whit Young&quot;);
console.log(person.name());
console.log(person.firstName());
console.log(person.lastName());</code></pre></div>

<p>In general, it&#39;s better to add <em>getter</em> and <em>setter</em> methods than to allow
access to private data.</p>

<p><aside>
<strong>Private Data Convention</strong></p>

<p>There is no formal way in JavaScript to protect the data of an object (that
statement is only partially true). Therefore, we use an underscore before the
property name to indicate to all other programmers that they shouldn&#39;t access
it.</p>

<p>In fact, JavaScript can fully encapsulate data via closures. It just can&#39;t do
so for the properties of an object.
</aside></p>

</div>



    </section>

    <footer class="pure-u-1">
      &copy; 2014. All rights reserved.
      <span>v0.0.1</span>
    </footer>
  </body>
</html>
