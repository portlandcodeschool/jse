// ======= Backbone's Extend =======

// Pattern:
var SUBCLASS = SUPER.extend(protoAnnex);

var SUBCLASS = SUPER.extend({
	//begin object literal...
	inheritedProp: 'I live in SUBCLASS.prototype'
})

// DIAGRAM...


var sub = new SUBCLASS();
sub instanceof SUBCLASS; //true
sub instanceof SUPER;  //true
sub.inheritedProp //I live...prototype
sub.hasOwnProperty(inheritedProp) // false


// JOINT EXERCISE:
// Let's write an implementation of extend().
// 1) Attach it to Function.prototype so that every Ctor inherits it:
Function.prototype.extend = function(protoAnnex) {
	//2) SUPER is this.  Create a subclass SUB of it.

	//3) Give SUB.prototype all the properties in protoAnnex

}

// Approximate solution:
Function.prototype.extend = function(protoAnnex) { // method of any function...
	var SUPER = this; //the function to be subclassed
	function SUB() { // the subclass ctor
		SUPER.call(this); //call Super ctor to initialize new instance
	}

	// Make SUB a subclass of SUPER:
	var proto = Object.create(SUPER.prototype); //the subclass prototype
	SUB.prototype = proto;
	proto.constructor = SUB;

	// Copy protoProps into subclass prototype:
	for (var prop in protoAnnex) {
		proto[prop] = protoAnnex[prop];
	}
	// OR use underscore library function:
	//_.extend(proto,protoAnnex); //different meaning:
								// _.extend(A,B) -> merge B into A


	return SUB;
}

// Usage examples:
function Duck() {} //superclass
Duck.prototype.feet = 2;
Duck.prototype.noise = 'quack';

var MutantDuck = Duck.extend({feet:3}); //subclass
var duck = new MutantDuck();
duck instanceof MutantDuck; //true
duck instanceof Duck; //true
// Inherited from MutantDuck:
duck.feet;
duck.hasOwnProperty('feet'); //false
// Inherited from Duck:
duck.noise;
duck.hasOwnProperty('noise'); //false


// Subclass of Array:
var MyArray = Array.extend({
	// begin object literal...
	shuffle: function() {
		// Knuth-Fisher-Yates, modified from http://bost.ocks.org/mike/shuffle/
		var end = this.length, temp, i;
 		while (end>1) {
   			i = Math.floor(Math.random() * end--);
   			temp = this[end];
   			this[end] = this[i];
		    this[i] = temp;
 		}
	}
})

var arr = new MyArray();
arr.push(1);
arr.push(2);
arr.push(3);
arr.shuffle();
arr

// Notice: Definition of subclass ctor (e.g. MyArray) is invisible.


// ===== Backbone =====

// We've explored the SUPER.extend() pattern generally,
// as if it were universal in JS,
// but it's specific to Backbone...

// Backbone offers a family of superclasses
// which need to be subclassed before they're used.

// Backbone.SOMETHING.extend(OBJ) makes a subclass of Backbone.SOMETHING
//  and copies any properties of OBJ into its prototype

// Each Backbone.SOMETHING class implements one role
// in the MV(C) pattern:

// Backbone.View  (V)
//   Manages one region of a GUI
// Backbone.Model (M)
//   Holds one record/unit of data
// Backbone.Collection (not C)
// ("C" in MVC means Controller, not Collection)
//	 Manages a set of Models and their collective behavior


// Backbone requires:
//  JQuery ($),
//	Underscore (_) or variant (e.g. lodash)



// ---- EXERCISE 1 ----
// Modify your checkerboard.html to include
// jQuery, underscore, and Backbone

// https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.2/underscore-min.js
// https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.1.2/backbone-min.js

// Load, then check for these:
$
_
Backbone



// ---- Backbone.View ----


// View onto existing DOM element:
var MyView = Backbone.View.extend({
	el: '#someID',
	render: function() {
		//draw stuff within this.el
		this.el.innerHTML = 'hello';
		// OR
		this.$el.html('hello');
	}
})

var view = new MyView();
MyView.prototype.el // selector string
view.el  // DOM element
view.$el // JQ wrapper
view.render()

// Diagram...



// View onto new custom DOM element:
var MyView = Backbone.View.extend({
	el: '<p>',
	render: function() {
		this.$el.html('hello');
	}
})

var view = new MyView();
view.$el.appendTo(document.body);
view.render();



// View onto default DOM element (<div>):
var MyView = Backbone.View.extend({
	// omit el property; uses '<div>'
	render: function() {
		this.$el.html('hello');
	}
})

var view = new MyView();
view.$el.appendTo(document.body);
view.render();




// ---- EXERCISE 2 ---- 

// Include a new file in your checkerboard project,
// which adds Backbone views to the DOM structure
// generated by ctor Checkerboard().

// Create a Backbone View subclass called SqView
//  which uses your first checkboard square as its `el`.
// Include a render() method which decorates only that square (e.g. turn it blue).

// Then make an instance of SqView, and use it to decorate that first square.

// -------------------

// LESSON: Instance-specific options:
var view = new MyView({ // options object is argument to Ctor
	el:'#someID' //override prototype's default
});


// ---- EXERCISE 3 ----  
// Generalize your SqView to work with any square.
var SqView = Backbone.View.extend({
	render: function () {
		//whatever...
	}
})
// Then create an instance to redecorate square #27 (or any other)

// What happens when you create an instance without providing any argument
// to the SqView ctor?


// ---- EXERCISE 4 ----
// Generate an array of 64 SqView instances, each attached (via its `el`)
// to a different checkerboard square.

// ---------------------

// LESSON:  Initialize method;
//			Standard vs. Custom options

var MyView = Backbone.View.extend(); //simple View subclass


var view = new MyView({a:'a', b:'b', el:'', id:'id', model:'model'});
view
// Only certain "standard" options are included automatically:
// model, collection, el, id, className, tagName, attributes, events

// Each has a specific meaning in BB...

// model & collection:  data objects displayed by this view
// el: an existing DOM element
// className: CSS classes to be set on el
// tagName: what type of element to generate (if not in el)
// attributes: an object {attr1:val1, attr2:val2, ...} to be set on el
// events: sets up event handlers


// DIAGRAM initialize role...

// initialize method receives arguments to ctor: 
var MyView = Backbone.View.extend({
	initialize: function(opts) {
		// all opts are received:
		console.log("Received opts: ", opts);
		// standard opts have already been included:
		console.log("Current props:", this);
	}
})
var view = new MyView({a:'a', b:'b', el:'', id:'id', model:'model'});
view


// Including custom instance properties:

//	initialize() method serves a proxy ctor;
//	use it to include custom options:

var MyView = Backbone.View.extend({
	// initialize serves as proxy ctor...
	initialize: function(opts) {
		//include only some opts
		this.custom = opts.custom;
	}
})
var view = new MyView({a:'a', b:'b', el:'', id:'id', model:'model'});
view


// Include all options:
var MyView = Backbone.View.extend({
	initialize: function(opts) {
		// include all opts
		_.extend(this,opts);
		// But beware: overwrites standard opts too!
	}
})
var view = new MyView({a:'a', b:'b', el:'', id:'id', model:'model'});
view




// Separate standard opts from custom ones:
var MyView = Backbone.View.extend({
	// initialize serves as proxy ctor...
	initialize: function(std,custom) {
		// ignore std opts, included automatically
		if (custom) {
			_.extend(this,custom);
		}
	}
})
var view = new MyView(	{el:'', id:'id', model:'model'},
						{a:'a', b:'b'} );
view





// ---- EXERCISE 5: ----
// Create another subclass of Backbone.View, named GridView,
// which will manage the entire grid.
// Attach it to your DOM element with the id 'checkerboard'.
// Give it an initialize method which generates an array of 64 SqView instances,
// each with an `el` of one of the checkerboard's squares.
// Give each sub-view an `id` property matching the `id` of its `el`.
// Store that array of sub-views in a custom property of the grid view.
// Give the grid view another method `children()` which returns the array of sub-views.




// ---- EXERCISE 6: ----
// Modify GridView so that when an instance `grid` makes its subviews, each one gets a
// custom property `parent` pointing back to `grid`, the GridView instance.




// ---- EXERCISE 7: ----
// Give the GridView instance a `render()` method which will call the `render()` of
// each of its children().




// ---- EXERCISE 8: ----
// Replace your original Checkerboard constructor by making GridView and its children do
// the work of generating and attaching their DOM elements, as well as linking to them
// with their respective `el`s.

// ---- EXERCISE 8a: ----
// Each child (square) view should create its own `el` (DOM element),
// and within its initialize() method, attach its new `el` as a DOM child of its
// parent's `el`.

// ---- EXERCISE 8b: ----
// Also within the child view's initialize method, style its `el` be red or black.
// You can use either its `id` property or a different initialization parameter to determine
// its color.

// Ignore the render() method for now.

// ---- EXERCISE 8c: ----
// Rewrite the grid (parent) view so that its initialize() method contains one or more loops
// to generate all of its child views (each of which will create its own `el`, as above).
// If you use a <table> structure, you may need to generate some <tr>s which do not have views,
// in addition to the <td>s of the child views.
// You may prefer to use <div>s or <li>s instead.



